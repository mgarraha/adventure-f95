module places
   implicit none

   public
   integer, parameter :: LOCSIZ = 150
   integer :: ATLOC(LOCSIZ), ABB(LOCSIZ)
   integer :: LINK(200), PLACE(100), FIXED(100)
   integer :: HOLDNG

contains

   subroutine DSTROY(OBJECT)

!  PERMANENTLY ELIMINATE "OBJECT" BY MOVING TO A NON-EXISTENT LOCATION.

      INTEGER OBJECT

      CALL MOVE(OBJECT,0)
      RETURN
   end subroutine DSTROY


   subroutine JUGGLE(OBJECT)

!  JUGGLE AN OBJECT BY PICKING IT UP AND PUTTING IT DOWN AGAIN, THE PURPOSE
!  BEING TO GET THE OBJECT TO THE FRONT OF THE CHAIN OF THINGS AT ITS LOC.

      INTEGER OBJECT
      INTEGER I,J

      I=PLACE(OBJECT)
      J=FIXED(OBJECT)
      CALL MOVE(OBJECT,I)
      CALL MOVE(OBJECT+100,J)
      RETURN
   end subroutine JUGGLE


   subroutine MOVE(OBJECT,WHERE)

!  PLACE ANY OBJECT ANYWHERE BY PICKING IT UP AND DROPPING IT.  MAY ALREADY BE
!  TOTING, IN WHICH CASE THE CARRY IS A NO-OP.  MUSTN'T PICK UP OBJECTS WHICH
!  ARE NOT AT ANY LOC, SINCE CARRY WANTS TO REMOVE OBJECTS FROM ATLOC CHAINS.

      INTEGER OBJECT,WHERE
      INTEGER FROM

      if (OBJECT <= 100) then
         FROM=PLACE(OBJECT)
      else
         FROM=FIXED(OBJECT-100)
      end if
      if (FROM > 0 .and. FROM <= 300) CALL CARRY(OBJECT,FROM)
      CALL DROP(OBJECT,WHERE)
      RETURN
   end subroutine MOVE


   integer function PUT(OBJECT,WHERE,PVAL)

!  PUT IS THE SAME AS MOVE, EXCEPT IT RETURNS A VALUE USED TO SET UP THE
!  NEGATED PROP VALUES FOR THE REPOSITORY OBJECTS.

      INTEGER OBJECT,WHERE,PVAL

      CALL MOVE(OBJECT,WHERE)
      PUT=(-1)-PVAL
      RETURN
   end function PUT


   subroutine CARRY(OBJECT,WHERE)

!  START TOTING AN OBJECT, REMOVING IT FROM THE LIST OF THINGS AT ITS FORMER
!  LOCATION.  INCR HOLDNG UNLESS IT WAS ALREADY BEING TOTED.  IF OBJECT>100
!  (MOVING "FIXED" SECOND LOC), DON'T CHANGE PLACE OR HOLDNG.

      INTEGER OBJECT,WHERE
      INTEGER TEMP

      if (OBJECT <= 100) then
         if (PLACE(OBJECT) == -1) RETURN
         PLACE(OBJECT)=-1
         HOLDNG=HOLDNG+1
      end if
      if (ATLOC(WHERE) == OBJECT) then
         ATLOC(WHERE)=LINK(OBJECT)
         RETURN
      end if
      TEMP=ATLOC(WHERE)
      do while (LINK(TEMP) /= OBJECT)
         TEMP=LINK(TEMP)
      end do
      LINK(TEMP)=LINK(OBJECT)
      RETURN
   end subroutine CARRY


   subroutine DROP(OBJECT,WHERE)

!  PLACE AN OBJECT AT A GIVEN LOC, PREFIXING IT ONTO THE ATLOC LIST.  DECR
!  HOLDNG IF THE OBJECT WAS BEING TOTED.

      INTEGER OBJECT,WHERE
      
      if (OBJECT <= 100) then
         if (PLACE(OBJECT) == -1) HOLDNG=HOLDNG-1
         PLACE(OBJECT)=WHERE
      else
         FIXED(OBJECT-100)=WHERE
      end if
      if (WHERE <= 0) RETURN
      LINK(OBJECT)=ATLOC(WHERE)
      ATLOC(WHERE)=OBJECT
      RETURN
   end subroutine DROP

end module places
